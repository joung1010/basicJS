 /* JavaScript는 Single Threaded Language
 *   즉 언어 자체에는 멀티쓰레딩이 없다. 하지만 이 자바스크립가 동작하고 있는 브라우저 위에는
 *  즉 브라우저라는 프로그램 안에서는 여러가지의 쓰레드가 들어있다.
 * 그래서 브라우저 즉 웹 APIs 들을 이용하게 되면 멀티쓰레딩이 가능하고
 * JavaScript가 동작하는 실행환경(Javascript Runtime Environment) 다양한 방식을 이용해서 멀티쓰레딩같은 효과를 얻을 수 있다.
 *
 * 이 Javascript Runtime Environment 에서는 즉 자바스크립트가 실행되는 실행환경위에서는 멀티쓰레딩 뿐만 아니라
 * 이벤트 루프를 이용해서 조금더 다양한 동작이 가능하다
 *
 * 우리의 Web Application 이 브라우저 위에 올라가는 순간 자바스크립트 엔진이 우리가 작성한 소스코드를 한줄씩 한줄씩 해석하고
 * 분석하고 실행한다.
 * */
 /*
 *    ------------------------------------------------------------------------------------------------------------
 *                                              JavaScript Engine
 *          MemoryHeap                                 |                        Call Stack
 *    Data                                             |
 *                                                     |
 *                          Data                       |                    Second();
 *                                                     |
 *                                                     |
 *                  Data                               |------------------------------------------------
 *                                                     |
 *                       Data                          |
 *                 Data                                |                  fist()
 *                                                     |------------------------------------------------------
 *                                                     |                  main()
 *                      Data                           |
 *                                                     |
 *
 * ------------------------------------------------------------------------------------------------------------
 *
 *                  Source Code
 * */

 /*
 *
 *      Memory Heap : 변수를 선언해서 오브잭트할당, 문자열이나 숫자를 항당하게 되면 그 데이터들을 전부다 메모리 힙에 저장
 *
 *      CallStack : 우리가 실행하는 함수의 순서에 따라서 차곡 차곡 쌓아놓는다
 *                  -> 자료구조 LIFO ( Last In First Out) 제일 나중에 들어온 것이 제일 처음으로 나간다.
 *                  보총 stack 에는 push, pop, peek 과 같은 API 가 있다.
 *
 *
 *
 *
 *                                     |
 *                                     |
 *                                     |
 *                2                    |      --> push(2)
 *                                     |
 *-------------------------------------|
 *                                     |
 *                                     |
 *                                     |
 *                                     |
 *                 1                   |        --> push(1)
 *                                     |
 *                                     |
 *                                     |
 *  -------------------------------------
 *
 *
 *
 *          Pop();을하면
 *
 *
 *                                     |
 *                                     |
 *                                     |
 *                                     |
 *                 1                   |
 *                                     |
 *                                     |
 *                                     |
 *  -------------------------------------
 *
 *
 *
 * */


 function second() {
     console.log('Hello');
     return;
 }

 function first() {
     second();
     return;
 }

 function main() {
     first();
     return;
 }

 main ();
 /*

                                                     Call Stack
 *
 *
 *                                                                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *                                               second()                                               |
 *                                                                                                      |
 *                                                                                                      |
 *-------------------------------------------------------------------------------------------------------
 *
 *                                                                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *                                              first()                                                  |
 *                                                                                                      |
 *                                                                                                      |
 *-------------------------------------------------------------------------------------------------------
 *                                                                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *                                          main()                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *                                                                                                      |
 *-------------------------------------------------------------------------------------------------------
 *
 *
 *   처음에 main() 이 먼저 호출 되었기 때문에 main()이 먼저 callstack에 들어가게 된다.
      그리고 main()안에서 first()가 호출되서 callstack에 들어가게 된다
 *    first()안에서 second()가 호출 했기 때문에 second()가 callstack에 들어가게 된다
      그리고 second에서 hello를 출력 하고 return을 했는데 그럼 어디로가지????
 *      --> 이때 callstack을 보게된다.
        --> second()가 끝나면 first()로 가면 되는 구나!!!
        그래서 callstack에는 어디로 돌아와야 되는지 정보도 포함
        --> first가 끝나면 main()으로 돌아가게 되고 main() 안에도 어디까지 실행이 됐는지 기억하고 있기 때문에
        main() 안의 first()다음의 return이 호출되면 ccallstack안에는 아무것도 남아 있찌 않는다.
    그래서 모든 프로세스와 쓰레드 안에는 각각 저마다의 callstack이 있다
    왜냐 일을 수행할때 어디서 왔꼬 어디로 가야하는지 정보를 기억해야하기 때문이다.
 * */


 function endLess() {
     endLess();
 }

 endLess();

 // 위의 함수와 같은 경우에는 콜스택이 어떻게 쌓일까????
 /*
 *  endLess*()가 호출되면 해당 함수로가서 해당 코드 블럭안의 내용을 실행한다
 *  해당 블록은 자기자신을 호출한다 --> callstack에 쌓임
 *  다시 자기자신으로 가서 다시호출 --> callstack에 쌓임
 *          .
 *          .
 *          .
 *  계속 계속 endLess()가 callstack 에 쌓이다가 결국
 * Error Maximum callstack size exceeded 가 발생
 *  이러한 함수를 재귀함수라고 한다. 재귀함수는 매우 유용하지만 잘못하용하면 이러한 문제가 발생한다.
 * */

