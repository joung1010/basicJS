1. fast-forward merges
    :master branch에서 새로운 branch 가 생성된 이후에 master branch 의 변동사항이 없다면
    merge를 할때 단순히 master branch가 가리키고 있는 포인터를 d가 아닌 f로 롬겨 놓기만 하면 된다.
    그리고 branch  를 삭제한다.

                  -----  e <-- f <== feature A
                  ↓
a <-- b <-- c <-- d <== master branch

                |
                |       fast - forward merges
                ↓

                  -----  e <-- f <== master branch
                  ↓
a <-- b <-- c <-- d

단점 : 히스토리에 merge 가 되었다는 사실이 남지 않는다.
        feature A 브랜치가 master 브랜치에 merge 가 되었다는 것이 commit으로 남지 않는다

만약 merge 할때 fast forward 를 하고 싶지 않을때
git merge --no-ff 브랜치명: 해당 옵션을 주면 fast-forward 하지마 라는 옵션
--> merge commit이 생성됨


2. Three-way merges
    : merge 시 새로운 commit 을 만들고 싶거나
     또는 fast-forward 가 불가능한 상황이 있다.
     master branch 에서 feature A 가 파생이 된 다음에 새로운 commit이 있다면
     이때는 fast-forward 가 불가능하다.
     이때 만약 master 가 가리키는 포인터를 f 를 가리키게 되면
     f 는 e를 가리키고 e는 d를 가리키기 때문에 g 커밋의 변경사항을 잃어버린다.

     --> 그래서 그 원래의 branch 에서 새로운 commit 이 발생했다면 Three-way merges 를 사용
     즉 베이스 branch 인 master branch 와 파생된 feature A branch 의 변동사항을 모두 합해서 merge commit 을 만든 다음에 master branch 에 commit


                  -----  e <-- f    <== feature A
                  ↓
a <-- b <-- c <-- d <-- g       <== master branch
                |
                |   Three-way merges
                ↓

                  -----  e <-- f    <== feature A
                  ↓            ↑
a <-- b <-- c <-- d <-- g  <-- h <== master branch
                           (merge commit)

git merge 명령어를 사용하면 fast-forward 가 가능하면 fast-forward 를 실시하고 그렇지 않을때는
merge commit 을 하게된다.

add) Three-way merges 를 해야 하는 상황해서 fast-forward merges 는 못하는 걸까????

                  -----  e <-- f    <== feature A
                  ↓
a <-- b <-- c <-- d <-- g       <== master branch

feature A 가 파생된 시점인 즉 feature A 의 첫번째 commit 인 e 가 가리키고 있는 commit d 이것이 파생된 commit 이다.
단순히 e 가 가리키고 있는게 d 가 아니라 g 로 변경한다면

                        -----  e <-- f    <== feature A
                        ↓
a <-- b <-- c <-- d <-- g       <== master branch

즉 feature A 브랜치를 master 브랜치의 가장 최신버전 g 로 rebase를 한다면 이 상황에서는 fast-forward가 가능하다.
주의사항 : 만약 나혼자 feature A 브랜치를 사용하고 있으면 언제든지  rebase 가 가능하지만 만약 다른 사람들과 함께 feature A 브랜치를 사용하고 있다면
조금 주의할 필요가 있다.

rebase  를 하게되면 e가 가리키고 있는 포인터를 d 가 아니라 g 로 변경해야 되는데
이렇게 포인터의 정보를 변경하게 되면 기존의 commit 을 유지하는 것이 아니다 .
commit 은 불변의 진리 이다. 그래서 변경사항이 발생하게 되면 새로운 commit 을 만들게 된다.
즉 겉으로는 똑같아 보이지만 실제로는 다른 e 와 f 의 커밋이 생기기 때문이다
만약 다른 개발자가 해당 branch 에서 작업하고 있다면 내가 rebase 하고 push를 해서 서버에 업데이트 하게 도면
다른 개발자가 가지고 있는 feature A 의 e 와 f 는 전혀 다른 commit 이기 때문에 merge conflict 가 발생할 수 있다.